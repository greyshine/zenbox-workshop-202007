<!DOCTYPE html>
<meta charset="utf-8">
<style>
    html {
        background-color: black;
    }

    html,
    html * {
        box-sizing: border-box;
    }

    body {
        padding: 0;
        margin: 0;
    }

    svg {
        background-color: hsla(0, 0%, 100%, 0.1);
    }

    text {
        font-family: monospace;
        fill: white;
    }

    .node {
        opacity: 0.3;
    }

    .link {
        pointer-events: all;
        opacity: 0.2;
    }

    .node circle {
        pointer-events: all;
    }

    path {
        fill: none;
    }

    div.tooltip {
        font-family: Menlo, monospace;
        position: absolute;
        background-color: white;
        max-width: 200px;
        height: auto;
        padding: 0.25rem;
        border-style: solid;
        border-radius: 4px;
        border-width: 1px;
        box-shadow: 3px 3px 10px rgba(0, 0, 0, .5);
        pointer-events: none;
    }

    div.option {
        display: none;
        position: absolute;
        left: 0;
        top: 0;
    }

    output#log {
        display: block;
        position: absolute;
        right: 1rem;
        top: 1rem;
        color: hsla(0, 0%, 100%, 0.4);
        font-family: Menlo, monospace;
        font-size: 0.8rem;
        line-height: 1.5;
    }

    .cell,
    .swatch,
    .label {
        font-family: Menlo, monospace;
        font-size: 0.6rem;
        opacity: 0.4;
    }
</style>

<body>
    <output id="log"></output>
</body>
<script src="libs/d3/d3.v4.min.js"></script>
<script src="libs/d3/d3-legend/2.24.0/d3-legend.min.js"></script>
<!-- <script src="libs/d3/d3-scale-chromatic.v1.min.js"></script> -->
<script src="libs/lodash.js/3.5.0/lodash.min.js"></script>
<script>
    /** Force Direction Graph
     *
     *  @desc written in d3.v4
     *        - nodes are updating, see updateData(), resetData()
     *        - nodes can be fixed by a click
     *        - fixed nodes can be released by doubleclick
     *
     * @package D3 Datavisualization
     * @module force_directed_graph
     * @author Michael <michael.reichart@gfu.net>
     * @version v1.0.0
     * @since 2019-12-22
     * @see i.e. inspired by Alejandro Suarez {https://bl.ocks.org/almsuarez/295c4ceb007e85e311b09208b342c444}
     * @license MIT {https://opensource.org/licenses/MIT}
     * @copyright (c) 2019 Michael Reichart, Cologne
     */

    !(function () {
        'use strict';
        // - - - - - - - - - -
        // Global declarations
        // - - - - - - - - - -
        let
            canvas,
            colorScale,
            color,
            currNodes,
            currLinks,

            dataFrame,
            dataLinksCount,
            dataLinksBySource,

            legendSequential,
            link,
            linkedByIndex = {},

            messages = ['ready.'],

            node,

            simulation,
            svg,

            temp = [],
            tooltip;

        // - - - - - - - - - -
        function loadData() {
            d3.json("assets/data/little_dataframe.json", function (error, dataFrame) {
                if (error) throw error;
                setCurrentData(dataFrame);
                aggregate();

                setSimulation();

                drawLinks()

                addNodeBehaviour();
                drawNodes();

                setUpdateIntervals();
            });
        }

        // - - - - - - - - - -
        // Event handler
        // - - - - - - - - - -
        function onDragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function onDragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function onDragEnded(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            //d.fx = null;
            //d.fy = null;
        }

        function onReleaseNode(d) {
            d.fx = null;
            d.fy = null;
        }

        function tooltip_onMouseOut() {
            tooltip
                .transition()
                .duration(100)
                .style("opacity", 0);
        }

        function onMouseMove() {
            tooltip
                .style("left", (d3.event.pageX) + "px")
                .style("top", (d3.event.pageY + 10) + "px");
        }

        function tooltip_onMouseOver(d, i) {
            tooltip
                .transition()
                .duration(300)
                .style("opacity", .8);

            tooltip
                .html(d.id + "<br/>group:" + d.group)
                .style("left", (d3.event.pageX) + "px")
                .style("top", (d3.event.pageY + 10) + "px");
        }

        function fade_onMouseOver() {
            fade(0.1);
        }

        function fade_onMouseOut() {
            fade(1);
        }

        // - - - - - - - - - -
        // Setter
        // - - - - - - - - - -
        function setCanvas() {
            canvas = {
                width: window.innerWidth,
                height: window.innerHeight
            }
        }

        function setSvg() {
            svg = d3.select('body')
                .append('svg')
                .attr('width', canvas.width)
                .attr('height', canvas.height)
        }

        function setColorScale() {
            colorScale = d3.schemeCategory20;
        }

        function setColor() {
            color = d3.scaleOrdinal(colorScale)
                .domain(['Am', 'An', 'Ar', 'As', 'Ba', 'Br', 'Ch', 'Cn', 'Cy', 'Gl', 'Gy', 'Li', 'Os',
                    'Pr', 'Vi',
                    'Zy'
                ]);;
        }

        function setTooltip() {
            tooltip = d3.select("body")
                .append("div")
                .classed("tooltip", true)
                .style("opacity", 0);
        }

        function setCurrentData(data) {
            currNodes = data.nodes;
            currLinks = data.links;
        }

        function setSimulation() {
            simulation = d3.forceSimulation()
                .nodes(currNodes)
                .force('link', d3.forceLink().id(d => d.id))
                .force('charge', d3.forceManyBody().strength(5))
                .force('center', d3.forceCenter(canvas.width / 2, canvas.height / 2))
                .force('collide', d3.forceCollide(25))
                .on('tick', ticked);

            simulation.force('link')
                .links(currLinks);
        }

        function setUpdateIntervals() {
            d3.interval(function () {
                updateData();
                restart();
                log(currLinks.length)
            }, 4000, d3.now());

            d3.interval(function () {
                resetData();
                restart();
            }, 4000, d3.now() + 2000);
        }

        // - - - - - - - - - -
        // Draw nodes and links
        // - - - - - - - - - -
        function addNodeBehaviour() {
            try {
                node = svg.selectAll('.node')
                    .data(currNodes)
                    .enter()
                    .append('g')
                    .attr('class', 'node')
                    .call(d3.drag()
                        .on("start", onDragstarted)
                        .on("drag", onDragged)
                        .on("end", onDragEnded)
                    );
            } catch (error) {
                log('a addNodeBehaviour error occured ...');
            }
        }

        function drawNodes() {
            try {
                // Draw notes without mouse event listeners
                node
                    .append('circle')
                    .classed('node', true)
                    .attr('data-id', function (d, i) {
                        return d.id;
                    })
                    .attr('r', function (d, i) {
                        let r;
                        if (dataLinksCount && dataLinksCount[d.id]) {
                            r = dataLinksCount[d.id] * 3;
                        } else {
                            r = 0;
                        }
                        if (r < 5) r = 5;
                        return r;
                    })
                    .attr("style", function (d, i) {
                        return 'fill:' +
                            color(d.group) +
                            ';'
                    })
                    .append('text')
                    .attr('fill', 'white')
                    .text('hey');

                node
                    .on('mouseover.fade', fade_onMouseOver)
                    .on('mouseout.fade', fade_onMouseOut)

                    .on('mouseover.tooltip', tooltip_onMouseOver)
                    .on("mouseout.tooltip", tooltip_onMouseOut)

                    .on("mousemove", onMouseMove)
                    .on('dblclick', onReleaseNode);
            } catch (error) {
                log('a drawNodes error occured ...');
            }
        }

        function addLinkBehaviour(link) {
            //Add mouseover events to links
            link.attr('class', 'link')
                .on('mouseover.fade', fade_onMouseOut)
                .on('mouseout.fade', fade_onMouseOut)

                .on('mouseover.tooltip', tooltip_onMouseOver)
                .on("mouseout.tooltip", tooltip_onMouseOut)

                .on("mousemove", onMouseMove);
        }

        function drawLinks() {
            link = svg
                .selectAll('.link')
                .exit()
                .remove()
                .data(currLinks)
                .enter()
                .append('path')
                .classed('link', true)
                .attr('style', function (d, i) {
                    return 'stroke:' +
                        color(d.value) +
                        ';' +
                        'stroke-width:' +
                        (Math.sqrt(d.value) * 2) + ';';
                });

            addLinkBehaviour(link);
        }

        function addNodes() {
            currNodes.push({
                "T": ["Mi", "Ch"],
                "Q": ["sp", "sp", "tr", "ad"],
                "id": currNodes.length,
                "class": 'nodeNew'
            });

            currLinks = [];
            for (let i = 0; i < currNodes.length; i += 1) {
                let
                    source = Math.floor(Math.random() * (currNodes.length - 1)),
                    target = currNodes.length - 1;

                currLinks.push({
                    "source": source,
                    "target": target,
                    T: "Mi"
                });

                console.log(source, target, currNodes.length, currLinks.length);
            };

        }
        // - - - - - - - - - -
        // Update and reset Data
        // - - - - - - - - - -
        function updateData() {
            try {
                addNodes();
                temp[0] = currLinks.pop();
            } catch (error) {
                log('error', 'in updataData');
            }
        }

        function resetData() {
            currLinks.push(temp[0]);
        }

        function aggregate() {
            // - - - - - - - - - -
            // Aggregate data
            // - - - - - - - - - -
            // links by source
            // ! .entries() builds an array!
            dataLinksBySource = d3.nest()
                .key(function (d, i) {
                    return d.source;
                })
                .entries(currLinks);
            // - - - - -
            // console.log(dataLinksBySource);
            // - - - - -

            // count links per name
            // ! .object() builds an object!

            dataLinksCount = d3.nest()
                .key(function (d, i) {
                    return d.source;
                })
                .rollup(function (v) {
                    return v.length;
                })
                .object(currLinks);
            // - - - - -
            // console.log(dataLinksCount);
            // - - - - - - - - - -
        }

        // - - - - - - - - - -
        // Simulation
        // - - - - - - - - - -
        function ticked() {
            try {
                // link
                //     .attr('x1', d => d.source.x)
                //     .attr('y1', d => d.source.y)
                //     .attr('x2', d => d.target.x)
                //     .attr('y2', d => d.target.y);
                link.attr("d", linkPath)
                node.attr('transform', d => `translate(${d.x},${d.y})`)
            } catch (error) {
                console.log(error);
                log('error', 'in ticked');
            }
        }

        function restart() {
            try {
                node = node.data(currNodes);

                node.enter()
                    .insert('circle')
                    .attr('r', 5)
                    .classed('node', true)
                    .attr('cx', function (d, i) {
                        return Math.random() * canvas.width;
                    })
                    .attr('cy', function (d, i) {
                        return Math.random() * canvas.height;
                    })
                    .attr("style", function (d, i) {
                        return 'fill:' +
                            color(d.group) +
                            ';'
                    });

                node.exit().remove();

                link = link.data(currLinks);

                link.exit().remove();

                link = link.enter()
                    .append('path')
                    .call(function (link) {
                        link
                            .transition()
                            .attr("stroke-opacity", 1)
                            .attr("d", linkPath)
                            .attr('stroke', function (d) {
                                return color(d.T);
                            })
                    })
                    .merge(link);

                simulation.nodes(currNodes);
                simulation.force("link").links(currLinks);
                simulation.alpha(1).restart();

            } catch (error) {
                log('error', 'in restart');
            }
        }

        // - - - - - - - - - -
        // Other
        // - - - - - - - - - -
        function linkPath(d) {
            try {
                let string,
                    dx = (d.target.x - d.source.x),
                    dy = (d.target.y - d.source.y);

                if (!d.source.x) d.source.x = canvas.width / 2;
                if (!d.source.y) d.source.y = canvas.height / 2;
                if (!d.target.x) d.target.x = canvas.width / 2 + 10;
                if (!d.target.y) d.target.y = canvas.height / 2 + 10;

                string = "M" +
                    Math.round(d.source.x) +
                    "," +
                    Math.round(d.source.y) +
                    "L" +
                    Math.round(d.target.x) +
                    "," +
                    Math.round(d.target.y);

                return string

            } catch (error) {
                log('error', 'in linkPath', '<br/>' + error.message);
            }
        }

        function isConnected(a, b) {
            return linkedByIndex[`${a.index},${b.index}`] ||
                linkedByIndex[`${b.index},${a.index}`] ||
                a.index === b.index;
        }

        function fade(opacity) {
            return d => {
                node.style('stroke-opacity', function (o) {
                    const thisOpacity = isConnected(d, o) ? 1 : opacity;
                    this.setAttribute('fill-opacity', thisOpacity);
                    return thisOpacity;
                });

                link.style('stroke-opacity', o => (o.source === d || o.target === d ? 1 : opacity));

            };
        }

        /** In-page logging
         * @desc uses an output element to log
         *       strings within the svg graph
         * @version 1.0.0
         * 
         * @example log('any string 1', 'any string 2')
         * 
         * @param {any} _arguments to handle one or more values
         * @returns none
         */
        function log() {
            let string = '',
                style = '',
                prefix = '',
                suffix = '';

            for (let i = 0; i < arguments.length; i += 1) {

                switch (arguments[i]) {
                    case 'error':
                        prefix = '<i style="color:red;opacity:0.5;">';
                        suffix = '</i>';
                        string += prefix + arguments[i] + ' ';
                        break;
                    case 'warning':
                        prefix = '<i style="color:yellow;">';
                        suffix = '</i>';
                        string += prefix + arguments[i] + ' ';
                        break;
                    default:
                        string += arguments[i] + ', ';
                        suffix = '';
                        break;
                }
            }
            string = string.substring(0, string.length - 2) + suffix;

            messages.push(string);

            if (messages.length >= 8) messages.shift();
            document.querySelector('#log').innerHTML = '';

            for (let i = 0; i < messages.length; i += 1) {
                document.querySelector('#log').innerHTML +=
                    '&gt; ' +
                    messages[i] +
                    '<br />';
            }

        }

        // - - - - - - - - - -
        function init() {
            setCanvas();
            setSvg();
            setColorScale();
            setColor();
            setTooltip();
            loadData();
        }

        function main() {
            init();
        }

        // - - - - - - - - - -
        // Main control
        // - - - - - - - - - -
        window.addEventListener('load', init);
        // - - - - - - - - - -
    }());
</script>